import tensorflow as tf

def build_input(dataset, data_path, batch_size, mode):

# 数据集参数
    if dataset == 'cifar10':
      label_bytes = 1
      label_offset = 0
      num_classes = 2
    elif dataset == 'cifar100':
      label_bytes = 1
      label_offset = 1
      num_classes = 100
    else:
      raise ValueError('Not supported dataset %s', dataset)
    image_size = 40
#    # 数据读取参数
    depth = 3
    
    data_files = tf.gfile.Glob(data_path)
    
    file_queue = tf.train.string_input_producer(data_files)
    
    reader = tf.TFRecordReader()
    
    _, value = reader.read(file_queue)
    
    img_features = tf.parse_single_example(
      value,
      features={
          'label': tf.FixedLenFeature([], tf.int64),
          'image_raw': tf.FixedLenFeature([], tf.string),
      })
    
    image = tf.decode_raw(img_features['image_raw'], tf.uint8)
    
    image = tf.reshape(image, [40, 40, 3])
    label = tf.cast(img_features['label'], tf.int32)
    label = tf.reshape(label, [1])

# print(image.shape)
# print(label.shape)
#%%%%
    if mode == 'train':
    # 增减图片尺寸
        image = tf.image.resize_image_with_crop_or_pad(
                image, image_size+4, image_size+4)
        # 随机裁剪图片
        image = tf.random_crop(image, [image_size, image_size, 3])
        # 随机水平翻转图片
        image = tf.image.random_flip_left_right(image)
        # 逐图片做像素值中心化(减均值)
        image = tf.image.per_image_standardization(image)
    
        # 建立输入数据队列(随机洗牌)
        example_queue = tf.RandomShuffleQueue(
        # 队列容量
        capacity=16 * batch_size,
        # 队列数据的最小容许量
        min_after_dequeue=8 * batch_size,
        dtypes=[tf.float32, tf.int32],
        # 图片数据尺寸，标签尺寸
        shapes=[[image_size, image_size, depth], [1]])
        # 读线程的数量
        num_threads = 16
    else:
    # 获取测试图片，并做像素值中心化
        image = tf.image.resize_image_with_crop_or_pad(
                image, image_size, image_size)
        image = tf.image.per_image_standardization(image)
    
    # 建立输入数据队列(先入先出队列）
    example_queue = tf.FIFOQueue(
    3 * batch_size,
    dtypes=[tf.float32, tf.int32],
    shapes=[[image_size, image_size, depth], [1]])
    # 读线程的数量
    num_threads = 1
       
    # 数据入队操作
    example_enqueue_op = example_queue.enqueue([image, label])
    # 队列执行器
    tf.train.add_queue_runner(tf.train.queue_runner.QueueRunner(
      example_queue, [example_enqueue_op] * num_threads))
    
    # 数据出队操作，从队列读取Batch数据
    images, labels = example_queue.dequeue_many(batch_size)
    # 将标签数据由稀疏格式转换成稠密格式
    # [ 2,       [[0,1,0,0,0]
    #   4,        [0,0,0,1,0]
    #   3,   -->  [0,0,1,0,0]
    #   5,        [0,0,0,0,1]
    #   1 ]       [1,0,0,0,0]]
    labels = tf.reshape(labels, [batch_size, 1])
    indices = tf.reshape(tf.range(0, batch_size, 1), [batch_size, 1])
    labels = tf.sparse_to_dense(
                  tf.concat(values=[indices, labels], axis=1),
                  [batch_size, num_classes], 1.0, 0.0)    
    #检测数据维度
    assert len(images.get_shape()) == 4
    assert images.get_shape()[0] == batch_size
    assert images.get_shape()[-1] == 3
    assert len(labels.get_shape()) == 2
    assert labels.get_shape()[0] == batch_size
    assert labels.get_shape()[1] == num_classes
   
    tf.summary.image('images', images)
    return images, labels
